<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.22">
<meta name="description" content="Documento Arquitectura GUI de los Servicios Climaticos">
<meta name="author" content="LCSC">
<title>LCSC CS-UI-FW</title>
<link rel="stylesheet" href="css/lcsc.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>LCSC CS-UI-FW</h1>
<div class="details">
<span id="author" class="author">LCSC</span><br>
<span id="email" class="email"><a href="mailto:lcsc_admin@listas.csic.es">lcsc_admin@listas.csic.es</a></span><br>
<span id="revnumber">version 0.1,</span>
<span id="revdate">2023-08-01</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduccion">Introduccion</a>
<ul class="sectlevel2">
<li><a href="#_filosofia_del_framework">Filosofia del Framework</a></li>
<li><a href="#_webpack">WebPack</a></li>
<li><a href="#_typescript">TypeScript</a></li>
</ul>
</li>
<li><a href="#_guia_rapida">Guia Rapida</a>
<ul class="sectlevel2">
<li><a href="#_prerequisitos">PreRequisitos</a></li>
<li><a href="#_instalacion_de_node_js">Instalacion de Node.JS</a></li>
<li><a href="#_visor_de_ejemplo">Visor de Ejemplo</a>
<ul class="sectlevel3">
<li><a href="#_primera_ejecuccion_del_visor_de_eejemplo">Primera Ejecuccion del visor de Eejemplo</a></li>
<li><a href="#_creacion_de_ficheros_publicables">Creacion de ficheros publicables</a></li>
</ul>
</li>
<li><a href="#_basic_drought_monitor">Basic Drought Monitor</a>
<ul class="sectlevel3">
<li><a href="#_duplicar_precipitaciones_extremas">Duplicar Precipitaciones extremas</a></li>
</ul>
</li>
<li><a href="#_cambios_en_el_nuevo_monitor">Cambios en el nuevo monitor</a>
<ul class="sectlevel3">
<li><a href="#_nombre_de_clase">Nombre de Clase</a></li>
<li><a href="#_configuración_minima">Configuración Minima</a></li>
<li><a href="#_cambio_de_la_fuente_de_datos">Cambio de la fuente de datos</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_esqueleto_de_un_visor">Esqueleto de un Visor</a>
<ul class="sectlevel2">
<li><a href="#_ficheros_de_configuracion">Ficheros de configuracion.</a>
<ul class="sectlevel3">
<li><a href="#_ficheros_basicos_node_webpack_typescript">Ficheros Basicos: Node + WebPack + TypeScript</a></li>
<li><a href="#_enviroment">Enviroment</a></li>
<li><a href="#_configuracion_del_visor">Configuracion del Visor</a></li>
</ul>
</li>
<li><a href="#_proceso_de_configuracion">Proceso de Configuracion.</a></li>
<li><a href="#_aplicacion">Aplicacion</a>
<ul class="sectlevel3">
<li><a href="#_index">Index</a></li>
<li><a href="#_visorapp">VisorApp</a>
<ul class="sectlevel4">
<li><a href="#_singleton">Singleton</a></li>
<li><a href="#_configuración">Configuración</a></li>
<li><a href="#_eventos_a_implementar">Eventos a implementar</a></li>
</ul>
</li>
<li><a href="#_dataservice">DataService</a>
<ul class="sectlevel4">
<li><a href="#_soporte_espacial">Soporte Espacial</a></li>
<li><a href="#_variables">Variables</a></li>
<li><a href="#_seleccion">Seleccion</a></li>
<li><a href="#_relacion_con_varid_netcdf">Relacion con varId (NetCDF).</a></li>
<li><a href="#_filtrado_de_datos">Filtrado de Datos</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_entorno_de_ejecución">Entorno de Ejecución</a>
<ul class="sectlevel2">
<li><a href="#_vision_general">Vision General</a>
<ul class="sectlevel3">
<li><a href="#_sc_frontal">sc-frontal</a></li>
<li><a href="#_sc_aemet_1">sc-aemet-1</a></li>
<li><a href="#_sc_aemet_prod">sc-aemet-prod</a></li>
</ul>
</li>
<li><a href="#_imagenes_docker">Imagenes Docker</a>
<ul class="sectlevel3">
<li><a href="#_lcsc_r">LCSC-R</a></li>
<li><a href="#_imagenes_de_los_visores">Imagenes de los visores.</a></li>
</ul>
</li>
<li><a href="#_jobs">Jobs</a></li>
<li><a href="#_utilidades">Utilidades</a></li>
</ul>
</li>
<li><a href="#_desarrollo_del_anemui_core">Desarrollo del AnemUI-core</a>
<ul class="sectlevel2">
<li><a href="#_modificacion_espacio_de_trabajo">Modificacion Espacio de trabajo</a></li>
<li><a href="#_publicacion_automatica_de_cambios">Publicacion Automatica de cambios.</a></li>
<li><a href="#_publicacion_manual_de_cambios">Publicacion Manual de cambios</a></li>
<li><a href="#_estabiliacion_de_version">Estabiliacion de Version.</a></li>
<li><a href="#_pruebas_de_software">Pruebas de software</a></li>
<li><a href="#_mocha">Mocha</a></li>
<li><a href="#_selenium">Selenium</a></li>
<li><a href="#_estructura_del_código_de_pruebas">Estructura del código de pruebas</a></li>
<li><a href="#_tests_método_it">Tests (método "it")</a></li>
<li><a href="#_utilización_de_la_clase_cstest_desde_los_script_de_cada_visor">Utilización de la clase csTest desde los script de cada visor</a></li>
<li><a href="#_ejecución_de_los_test">Ejecución de los test</a></li>
<li><a href="#_toma_de_imágenes_de_pantalla_y_borrado_de_archivos">Toma de imágenes de pantalla y borrado de archivos</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Documento de arquitectura para la GUI de los Servicios Climaticos</p>
</div>
<div class="imageblock text-center text-center">
<div class="content">
<img src="media/logo.svg" alt="FW Logo">
</div>
<div class="title">Figure 1. Framework Logo</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduccion">Introduccion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Para los diferentes Servicios Climaticos se ha decido partir el codigo de NC-WebMapper usando un framework de empaquetado. Ademas, se ha tenido en cuenta que a futuro la Interface se unificara con la version de Adaptecca, hecha en React.</p>
</div>
<div class="sect2">
<h3 id="_filosofia_del_framework">Filosofia del Framework</h3>
<div class="paragraph">
<p>O decisiones de alto nivel que guian el desarrollo de los visores</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se ha decidido usar WebPack e ir escribiendo el codigo en TypeScript para ir acercarnos a lo que requiere React. Anticipandos a problemas que pudieran Salir.</p>
</li>
<li>
<p>La vista de la UI se ha hecho desde cero, desacoplando la UI principal de LeafLet</p>
</li>
<li>
<p>Se usaran los resultados del proceso NC-WebMapper (times.js, nc, maps,&#8230;&#8203;)</p>
</li>
<li>
<p>La funcionalidad se ha copiado de la version NC-WebMapper, practicamente Tal Cual (se ha convertido a Type Script)</p>
</li>
<li>
<p>No se usan variables globales, salvo para la aplicacion en si misma, como punto de localizacion.</p>
</li>
<li>
<p>Obligatorio usar objetos. Salvo requisitos del navegador o utilidades no asignables a objetos.</p>
</li>
<li>
<p>Introduccion de <code>Promises</code> y <code>Asyc/Await</code> donde sea posible</p>
</li>
<li>
<p>Existira una libreria comun (<code>core</code>) que contendra el codigo comun a todos los visores. No tendra <code>main.js</code></p>
</li>
<li>
<p>Cada visor sera un proyecto Node.JS que tendra el <code>main.js</code> este fichero personalizara el visor (Varibles, paleta de color, &#8230;&#8203;)</p>
</li>
<li>
<p>Para simplificar la gestion de dependencias se usaran los Workspaces de Node</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_webpack">WebPack</h3>
<div class="paragraph">
<p>Webpack es una herramienta que transforma una aplicacion Node.JS en una aplicacion de navegador. A partir de un punto de entrada (<code>main.js</code>) es capaz de generar un HTML (<code>index.html</code>) y un javascript que contiene "todo" el codigo de la aplicacion Node.JS. Por defecto el codigo acaba optimizado y ofuscado, pero se puede configurar para que genere meta-informacion de tal forma que el visor de codigo del navegador muestre los ficheros originales.</p>
</div>
<div class="paragraph">
<p>Existen otras herramientas similares, como <code>Vitte</code>, <code>Parcel</code>,&#8230;&#8203; Pero React utiliza WebPack y usandolo nos encontraremos ya los problemas que nos surgira a futuro.</p>
</div>
<div class="paragraph">
<p>La configuracion de WebPack se realiza desde el <code>core</code>, siendo solo necesario pasar una poca informacion desde el visor. Como pasa en React</p>
</div>
</div>
<div class="sect2">
<h3 id="_typescript">TypeScript</h3>
<div class="paragraph">
<p>TypeScript o TS (<a href="https://www.typescriptlang.org" class="bare">https://www.typescriptlang.org</a>) es un lenguaje inventado por Microsoft que se puede resumir en "JavaScript Tipado". Esto implica que deba ser procesado antes de ejecutarse, realmente se traduce a JS. Veamos un ejemplo sencillo que unicamente ha sido necesario añadir los tipos:</p>
</div>
<div class="listingblock">
<div class="title">Version JavaScript</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">var degrees2meters = function(lon,lat) {
 var x = lon * 20037508.343 / 180;
 var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
 y = y * 20037508.343 / 180;
 return [x, y]
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Version TypeScript</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">function degrees2meters(lon:number, lat:number):[number,number] {
    var x = lon * 20037508.343 / 180;
    var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
    y = y * 20037508.343 / 180;
    return [x, y]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Al traducir el TS se puede configurar el compilador para que genere un JS optimizado para navegadores concretos, aprovechando las diferentes versiones fucniones disponibles en los mismos. En este caso es el propio WebPack quien se encarga de compilar el TS. Y en su conjunto son capaces de injectar modulos EcmaScript nuevos que aun no esten disponibles en los navegadores (Simpre y cuando haya un wrapper).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_guia_rapida">Guia Rapida</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En esta parte explicamos como empezar a desarrollar un visor, empezando por visualizar el visor de precipitaciones extremas y luego creando uno nuevo de ejemplo.</p>
</div>
<div class="sect2">
<h3 id="_prerequisitos">PreRequisitos</h3>
<div class="ulist">
<ul>
<li>
<p>Tener bajado el codigo en una carpeta como por ejemplo <code>VisorServiciosClimaticos</code> (la que se crea con <code>git clone</code>)</p>
</li>
<li>
<p>Tener los artefactos de un NetCDF publicados bajo una url comun</p>
<div class="ulist">
<ul>
<li>
<p>Se puede usar la ruta a un visor conocido como <a href="https://lisuarte.eead.csic.es/etm-proto1/">Monitor Temperaturas Extremas</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_instalacion_de_node_js">Instalacion de Node.JS</h3>
<div class="paragraph">
<p>Node.JS puede ser instalado directamente desde su pagina web o desde el repositorio de la distribucion, pero recomendamos usar <a href="https://github.com/nvm-sh/nvm">Node Version Manager</a>. Disponible para plataformas Posix (Linux/Mac)</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Para windows existe el mismo comando, que se puede instalar <a href="https://github.com/coreybutler/nvm-windows" class="bare">https://github.com/coreybutler/nvm-windows</a>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Para instalar <code>nvm</code> solo hay que ejecutar el auto instalador</p>
</div>
<div class="listingblock">
<div class="title">Instalacion de nvm</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash
$ echo 'export NVM_DIR="$([ -z "${XDG_CONFIG_HOME-}" ] &amp;&amp; printf %s "${HOME}/.nvm" || printf %s "${XDG_CONFIG_HOME}/nvm")"
[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvm' &gt;&gt; ~/.bash_profile
$ source ~/.bash_profile</code></pre>
</div>
</div>
<div class="paragraph">
<p>Con esto tendremos el gestor de versiones de node instaladas que nos facilitara seleccionar la version de node más adecuada, segun queramos. Con lo que procederemos a instalar la version 16 de node y actualizar npm a la ultima version.</p>
</div>
<div class="listingblock">
<div class="title">Instalacion de Node.JS 20 (ultima LTS)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">$ nvm install 20
$ nvm use 20
$ node -v
$ npm -v
$ npm install -g npm@latest
$ npm -v</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_visor_de_ejemplo">Visor de Ejemplo</h3>
<div class="sect3">
<h4 id="_primera_ejecuccion_del_visor_de_eejemplo">Primera Ejecuccion del visor de Eejemplo</h4>
<div class="paragraph">
<p>Para ejecutar el visor de ejemplo, debemos invocar el comando <code>dev</code> dentro del workspace <code>anemui-dev</code> con todas las depencias descargadas</p>
</div>
<div class="listingblock">
<div class="title">Primera ejecucion del visor</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">$ #git clone https://github.com/lcsc/AnemUI.git
$ cd AnemUI <i class="conum" data-value="1"></i><b>(1)</b>
$ npm install <i class="conum" data-value="2"></i><b>(2)</b>
$ npm -w anemui-demo run dev <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nos situamos en el directorio</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Descargamos las depencias, solo es necesario la primera vez</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Ejecucion propiamente dicha</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A partir del punto &lt;2&gt; solo sera necerario ejecutar <code>npm -w [visor] run [comando]</code> para lanzar el visor
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Una vez lanzado se abrira una pagina web con el visor</p>
</div>
<div class="imageblock text-center text-center">
<div class="content">
<img src="images/SC-EP-home.png" alt="Home Visor">
</div>
<div class="title">Figure 2. Home del visor de Ejemplo</div>
</div>
<div class="paragraph">
<p>WebPack lanzara un pequeño servidor web, que estara sirviendo las paginas al vuelo. De tal forma que si se hace una modificacion en los ficheros que usa la applicacion, esta se recompilara y se recargara en el navegador.</p>
</div>
<div class="paragraph">
<p>Ademas este servidor hace de proxy para suministrar los ficheros/artefactos de <code>NcWebMapper</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_creacion_de_ficheros_publicables">Creacion de ficheros publicables</h4>
<div class="paragraph">
<p>Por ultimo generaremos la carpeta <code>dist</code> con los ficheros HTML, JS y similares que require la applicacion.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">$ rm -rf anemui-demo/dist/ <i class="conum" data-value="1"></i><b>(1)</b>
$ npm -w anemui-demo run build <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>borramos la carpeta, para asegurarnos que la cache se borra.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>lanzamos el comando <code>build</code> para generar la carpeta dist</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El resultado seran todos los ficheros creados y que a su vez estene en la carpeta assets.</p>
</div>
<div class="imageblock text-center text-center">
<div class="content">
<img src="images/CarpetaDist.png" alt="">
</div>
<div class="title">Figure 3. Contenidos Carpeta Dist</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Ojo, estos ficheros requieren estar publicados en el mismo nivel que los artefactos generados por <code>NcWebMapper</code>. Los ficheros generado (como times.js, nc/&#8230;&#8203;) son localizados de forma relativa.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_basic_drought_monitor">Basic Drought Monitor</h3>
<div class="paragraph">
<p>Ahora procederemos a crear un Visor nuevo, en este caso sera una version simplificada del Monitor de sequias, al que pondremos dos variables, por ejemplo <code>cotton_spei_0.5</code> y <code>soybean_spei_0.5</code>.</p>
</div>
<div class="sect3">
<h4 id="_duplicar_precipitaciones_extremas">Duplicar Precipitaciones extremas</h4>
<div class="paragraph">
<p>En este paso lo que haremos sera copiar la carpeta y modificar los ficheros necesarios para crear el nuevo visor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">$ cd ..
$ cp -a AnemUI/anemui-demo my-drought-monitor
$ cd my-drought-monitor</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una vez que tengamos copiada la carpeta configuraremos el nuevo visor. Primeramente los atributos Node.JS, modificando el <strong><code>package.json</code> del proyecto: <code>my-drought-monitor/package.json</code></strong></p>
</div>
<div class="listingblock">
<div class="title">my-drought-monitor/package.json</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "name": "mdm-monitor", <i class="conum" data-value="1"></i><b>(1)</b>
  "version": "0.0.1",
  "description": "My Drought Monitor", <i class="conum" data-value="1"></i><b>(1)</b>
... <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Cambiar estas lineas</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>El resto se pueden dejar igual.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finalmente configuraremos la URL donde estan publicados los artefactos para que en desarrollo pueda localizarlos (proxy), esto se configura en el fichero de configuracion del visor <code>my-drought-monitor/csconfig.js</code></p>
</div>
<div class="listingblock">
<div class="title">my-drought-monitor/csconfig.js</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">const path = require('path');
const distPath = path.resolve(__dirname, 'dist');

module.exports = {
    distPath: distPath,
    proxyDataUrl:"https://servicios-climaticos.pti-clima.csic.es/etm-proto1/" <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>URL donde estan los artefactos <code>NcWebMapper</code>, en este caso nos sirve esta</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>El resto de ficheros del raiz (<code>tsconfig.json</code> y <code>webpack.config.js</code> los dejamos tal y como estan.)</p>
</div>
<div class="paragraph">
<p>En este punto conviene lanzar este nuevo visor para aseguranos que todo sigue funcionando.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">$ npm i <i class="conum" data-value="1"></i><b>(1)</b>
$ npm run dev <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>actualizamos las dependencias para que npm cree un enlace al nuevo proyecto. Esto se debe ejectuar al menos una vez</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>lanzamos la aplicacion</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>La applicacion la podemos dejar lanzada y asi ir viendo los cambios en vivo.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cambios_en_el_nuevo_monitor">Cambios en el nuevo monitor</h3>
<div class="paragraph">
<p>Ahora ha llegado el momento de ir cambiando el monitor. Los pasos son:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Cambiar el nombre de clase</p>
</li>
<li>
<p>Cambiar el titulo</p>
</li>
<li>
<p>Adaptar la fuente de datos</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_nombre_de_clase">Nombre de Clase</h4>
<div class="paragraph">
<p>Cambiaremos el nombre de la clase para evitar posibles colisiones de nombre. Modificaremos el fichero <code>my-drought-monitor/src/main.ts</code></p>
</div>
<div class="listingblock">
<div class="title">my-drought-monitor/src/index.ts</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">import { AppMDM } from "./App"; <i class="conum" data-value="1"></i><b>(1)</b>
export const app=AppMDM.getInstance() <i class="conum" data-value="1"></i><b>(1)</b>

app.configure().then((res)=&gt;{app.render()}).catch((res)=&gt;{console.error("error loading data...",res)})</code></pre>
</div>
</div>
<div class="paragraph">
<p>En el momento de salvar este cambio, veremos como la applicacion se recarga y nos avisa del error (no hemos cambiado la definicion en <code>my-drought-monitor/src/App.ts</code>)</p>
</div>
<div class="imageblock text-center text-center">
<div class="content">
<img src="images/ErrorClase.png" alt="Error nombre de Clase">
</div>
<div class="title">Figure 4. Error Nombre de Clase</div>
</div>
<div class="paragraph">
<p>Este error lo solucionaremos cambiando la definicion en el su codigo fuente: <code>my-drought-monitor/src/App.ts</code></p>
</div>
<div class="listingblock">
<div class="title">my-drought-monitor/src/App.ts</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">import {DataServiceApp, STR_ALL} from "anemui-core/src/ServiceApp"
import {loadTimesJs} from "anemui-core/src/data/CsDataLoader"
import { EpmOptionsService, EpmService, SUBVAR_5DAY } from "./EpmService";
import { CategoryRangePainter, PaletteManager } from "anemui-core/src/PaletteManager";
import { EpmInfo } from "./EmpInfo";

const VIEWER_NAME = "My Drought Monitor" <i class="conum" data-value="1"></i><b>(1)</b>
export class AppMDM extends DataServiceApp{ <i class="conum" data-value="1"></i><b>(1)</b>
    private static instance:AppMDM; <i class="conum" data-value="1"></i><b>(1)</b>

    public static getInstance(): AppMDM { <i class="conum" data-value="2"></i><b>(2)</b>
        if (!AppMDM.instance) {AppMDM
            AppMDM.instance = new AppMDM();
        }

        return AppMDM.instance;
    }

    private constructor(){
        super()
        this.service=new EpmService()
        this.optionsService=new EpmOptionsService()
        //this.infoDiv=new EpmInfo(this,"infoDiv") <i class="conum" data-value="3"></i><b>(3)</b>
    }

    public async configure():Promise&lt;AppMDM&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Esta linea esta cambiada</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Este metodo esta cambiado entero</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Esta linea configura el boton Info, se puede comentar</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Con estos cambios ya compilara y se vera igual que el Monitor de Precipitaciones Extremas.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuración_minima">Configuración Minima</h4>
<div class="paragraph">
<p>Al copiar de Monitor de precipitaciones nos hemos traido tambien codigo de personalizacion que no necesitamos, asi que cambiaremos las funciones</p>
</div>
<div class="listingblock">
<div class="title">my-drought-monitor/src/App.ts</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">...
export class AppMDM extends DataServiceApp{
...
        public async configure():Promise&lt;AppMDM&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

        let timesJs= await loadTimesJs();
        this.setTimesJs(timesJs,"tmax") <i class="conum" data-value="2"></i><b>(2)</b>

        let vars = this.service.getVars()
        this.state.varName=vars[0];
        let selections=this.service.getSelections(this.state)
        this.state.selection=selections[0]
        this.state.selectionParamEnable=this.service.isSelectionParamEnabled(this.state)
        if(!this.state.selectionParamEnable)
            this.state.selectionParam=this.service.getSelectionParam(this.state)


        if(this.fillStateFromUrl()){
            console.log("State Loaded")
        }else{
            this.changeUrl();
        }

        this.getMenuBar().setTitle(VIEWER_NAME)
        this.getSideBar().setSupportValues(this.service.getRenderers())
        this.getSideBar().setVariables(vars)
        this.getSideBar().setSelection(selections);

        this.getGraph().setParams("Eventos Sequia" , 1, true); <i class="conum" data-value="3"></i><b>(3)</b>

        //this.getDateSelectorFrame().setValidDates(timesJs.times[varId])

        return this;
    }

    public getLegendValues(): number[] { <i class="conum" data-value="1"></i><b>(1)</b>
        const STEPS = 10;
        let state = this.getState();
        let timesJs = this.getTimesJs();
        let dateIndex = state.selectedTimeIndex;
        let varId = state.varId;
        let varMin = timesJs.varMin[varId][dateIndex];
        let varMax = timesJs.varMax[varId][dateIndex];
        let step = (varMax - varMin) / STEPS;
        let values = [];
        for (let i = 0; i &lt; STEPS; i++)
            values.push(Math.round((varMin + i * step) * 100) / 100);

        return values;
    }

    <i class="conum" data-value="4"></i><b>(4)</b>
    //public hasSubVars(): boolean
    //public async filterValues(values: number[], t: number, varName: string): Promise&lt;number[]&gt;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Metodo a cambiar (copiar tal cual de esta pagina)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Valor Inicial del nc a cargar</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Cambio de nombre del grafico</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Metodos que no son necesarios para el visor minimo</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_cambio_de_la_fuente_de_datos">Cambio de la fuente de datos</h4>
<div class="paragraph">
<p>Para simplificar un poco las cosas, hay un "servicio" (<code>EpmService</code>) que tiene toda la informacion necesaria con las variables, asi que cambiremos esta clase.</p>
</div>
<div class="listingblock">
<div class="title">my-drought-monitor/src/MdmService.ts</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">import { CsDataService, STR_ALL, STR_CUSTOM } from "anemui-core/src/ServiceApp";
import { CsViewerData } from "anemui-core/src/data/CsDataTypes";
import { renderers } from "anemui-core/src/tiles/Support";

const VAR_TMAX = "Temperatura Maxima";
const VAR_TMIN = "Temperatura Minina";
export class MdmService implements CsDataService {
    getSubVars(state: CsViewerData): string[] {
        return [];
    }

    public getRenderers(): string[] {
        return renderers
    }

    public getVars(): string[] {
        return [VAR_TMAX,VAR_TMIN]
    }
    public getSelections(state: CsViewerData): string[] {
        let ret: string[]
        switch (state.varName) {
            case VAR_TMAX:
                ret = [STR_ALL,"20ºC", "30ºC"]
                break;
            case VAR_TMIN:
                ret = [STR_ALL,"-10ºC", "0ºC"]
                break;
            default:
                ret = []
        }
        ret.push(STR_CUSTOM)

        return ret;
    }

    public getSelectionParam(state:CsViewerData):number{
        if(state.selection==STR_ALL) return 0;
        return parseFloat(state.selection);
    }

    public isSelectionParamEnabled(state:CsViewerData){
        return (STR_CUSTOM == state.selection)
    }


    public getVarId(state: CsViewerData): string {
        switch (state.varName) {
            case VAR_TMAX:
                return "tmax"
            default:
                return "tmin"
        }
    }
}</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Esta clase es una copia de EpmService y crearemos el fichero <code>my-drought-monitor/src/MdmService.ts</code>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Podemos renombrar el fichero y modificar el codigo o crear el fichero nuevo
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Se han escogio valores arbitrarios para mostar que cada variable puede tener su propia seleccion
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Una vez que tengamos la fuente de datos preparada debemos instruir a la aplicacion de usar dicho servicio</p>
</div>
<div class="listingblock">
<div class="title">my-drought-monitor/src/App.ts</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">import { MenuBar } from "anemui-core/src/ui/MenuBar";
import {BaseApp} from "anemui-core/src/BaseApp"
import {loadTimesJs} from "anemui-core/src/data/CsDataLoader"
import { renderers } from "anemui-core/src/tiles/Support";
import { MdmService } from "./MdmService"; <i class="conum" data-value="1"></i><b>(1)</b>

export class AppMDM extends BaseApp{
    private static instance:AppMDM;
    private service:MdmService <i class="conum" data-value="1"></i><b>(1)</b>
...
    private constructor(){
        super()
        this.service=new MdmService() <i class="conum" data-value="1"></i><b>(1)</b>
    }
...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Linea a cambiar</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Es posible que de errores de compilacion hasta que no salvemos los dos ficheros
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_esqueleto_de_un_visor">Esqueleto de un Visor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La filosofia de este framework es que los visores proveean de la configuracion visual y que el codigo principal este en la libreria core.</p>
</div>
<div class="paragraph">
<p>Los Visores en principo deben ser más o menos iguales, salvo titulos y origenes de datos. Por ello deben tener una serie de ficheros de configuracion, utilizados por Typescript, Webpack,&#8230;&#8203; Y ademas suministrar una clase para comunicarse con el core y asi los diferentes modulos puedan localizar la informacion desde los artefactos de NcWebMapper.</p>
</div>
<div class="imageblock text-center text-center">
<div class="content">
<img src="media/VisorGeneral.svg" alt="Componentes Visor">
</div>
<div class="title">Figure 5. Componentes Vision General</div>
</div>
<div class="sect2">
<h3 id="_ficheros_de_configuracion">Ficheros de configuracion.</h3>
<div class="paragraph">
<p>Como toda aplicacion Node con WebPack/TypeScript el visor requiere unos cuantos ficheros de configuración y a los cuales hemos añadido un sistema de <code>Environments</code> y un fichero de configuracion del propio visor.</p>
</div>
<div class="sect3">
<h4 id="_ficheros_basicos_node_webpack_typescript">Ficheros Basicos: Node + WebPack + TypeScript</h4>
<div class="paragraph">
<p>Estos ficheros son los que configuran a nivel tecnico dichos sistemas. Inicialmente estos se copiaran de un visor ya existente y simplemente se personalizaran para el nuevo visor.</p>
</div>
<div class="paragraph">
<p>Pondremos aqui ejemplos del monitor de precipitaciones extremas.</p>
</div>
<div class="listingblock">
<div class="title">extreme-precipitation-monitor/package.json</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "name": "ep-monitor", <i class="conum" data-value="1"></i><b>(1)</b>
  "version": "0.0.1",
  "description": "Extreme Precipitations Monitor", <i class="conum" data-value="2"></i><b>(2)</b>
  "main": "src/index.ts", <i class="conum" data-value="3"></i><b>(3)</b>
  "devDependencies": {}, <i class="conum" data-value="6"></i><b>(6)</b>
  "scripts": { <i class="conum" data-value="4"></i><b>(4)</b>
    "build": "webpack",
    "build-wms": "NODE_ENV=wms webpack",
    "watch": "webpack --watch",
    "start": "webpack serve --open",
    "dev": "NODE_ENV=development webpack serve --open",
    "dev-wms": "NODE_ENV=developmentWms webpack serve --open"
  },<i class="conum" data-value="5"></i><b>(5)</b>
  "repository": {
    "type": "git",
    "url": "git+https://github.com/lcsc/VisorServiciosClimaticos.git"
  },
  "author": "LCSC",
  "license": "GPL-3.0",
  "bugs": {
    "url": "https://github.com/lcsc/VisorServiciosClimaticos/issues"
  },
  "homepage": "https://github.com/lcsc/VisorServiciosClimaticos#readme"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nombre del paquete, debe ser unico, recomendamos siglas seguidas de <code>-monitor</code> o lo que corresponda.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Descripcion del visor acutal</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Este es fichero principal, lo dejaremos tal cual.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Estos son los comandos disponibles para cada, para cada entorno debe existir al menos un build y un dev</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>El resto de campos se debe dejar igual.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Las dependencias unicas al visor se pueden añadir, usando los comandos <code>npm</code> a necesidad.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">anemui-demo/tsconfig.json</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "compilerOptions": {
      "outDir": "./dist/",
      "noImplicitAny": true,
      "sourceMap": true,
      "module": "es6",
      "target": "es5",
      "jsx": "react",
      "jsxFactory": "createElement",
      "allowJs": true,
      "moduleResolution": "node",
      "allowSyntheticDefaultImports":true
    }
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este Fichero configura el compilador de TypeScript, no es necesario tocarlo. En caso de necesidad se puede usar el del core.</p>
</div>
<div class="listingblock">
<div class="title">anemui-demo/webpack.config.js</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">const coreCfg  = require('@lcsc/anemui-core/webpack.config');
//const path = require('path');
//const distPath= path.resolve(__dirname, 'dist');

module.exports = (env,argv) =&gt; {
    let ret = coreCfg(env,argv);

//    ret.output.path=distPath;
    
    return ret;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por ultimo este fichero configura WebPack, pero como se puede ver lo que hace es llamar al fichero de igual nombre del <code>core</code>. La version del core, utilizara el <code>environment</code> y el fichero <code>csconfig.js</code> para configurar WebPack para ejecutar el comando y generar el entregable.</p>
</div>
</div>
<div class="sect3">
<h4 id="_enviroment">Enviroment</h4>
<div class="paragraph">
<p>Los entornos o <code>environments</code> es un tema para un apartado completo. El resumen es que podemos tener diferentes variables por entorno y usarlas en el codigo. Estas variables si son <code>const</code> pueden ser usadas por el optimizador de codigo para poner o quitar codigo (como por ejemplo version <code>wms</code> o nuestro renderizador)</p>
</div>
<div class="paragraph">
<p>En general existira un fichero llamado <code>env.[environment].js</code> por cada entorno declarado en los commandos declarados en el <code>package.json</code>.</p>
</div>
<div class="listingblock">
<div class="title">anemui-core/env/env.wms.js</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">module.exports={
    isWmsEnabled:true,
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como se puede ver, solo hay que exportar el objeto con los datos que necesitemos. Y ya veremos como acceder a ellos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuracion_del_visor">Configuracion del Visor</h4>
<div class="paragraph">
<p>Por ultimo la forma de configurar el visor, basicamente variables que dependen del visor y no del entorno a generar.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
De momento solo configura un par de cosas de webpack.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">extreme-precipitation-monitor/csconfig.js</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">const path = require('path');
const distPath = path.resolve(__dirname, 'dist');

module.exports = {
    distPath: distPath, <i class="conum" data-value="1"></i><b>(1)</b>
    proxyDataUrl:"https://calculador11.ipe.csic.es/global-drought-crops/" <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Directorio de salida</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Url usada en desarrollo para localizar los artefactos NcWebMapper</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
En desarrollo, cuando se ejecuta <code>npm -w [visor] run dev</code> (o similar), webpack lanza un servidor web (<a href="http://localhost:9000/index.html" class="bare">http://localhost:9000/index.html</a>) y para acceder a los artefactos NcWebMapper se configura un proxy reverso. De esta forma el navegador puede localizar los ficheros generados por NcWebMapper en el raiz del servidor (ej: <a href="http://locahost:9000/times.js" class="bare">http://locahost:9000/times.js</a>)
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_proceso_de_configuracion">Proceso de Configuracion.</h3>
<div class="paragraph">
<p>El proceso de configuracion se realiza en WebPack. Siguiendo el siguiente diagrama</p>
</div>
<div class="imageblock text-center text-center">
<div class="content">
<img src="media/ProcesoConfiguracion.svg" alt="][&quot;Proceso de Configuracion&quot;">
</div>
<div class="title">Figure 6. Proceso Configuracion</div>
</div>
<div class="paragraph">
<p>El proceso en grandes pasos es el siguiente</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>WebPack solicita la configuracion del modulo principal(el visor), que a su vez llama al core.</p>
</li>
<li>
<p>El core obtiene los datos de configuracion (<code>visor/csconfig.js</code>)</p>
</li>
<li>
<p>Posteriormente construye las variables del entorno</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Primero las propias del core</p>
</li>
<li>
<p>Luego las del visor</p>
</li>
<li>
<p>Por ultimo luego las junta usando la extension js (<code>&#8230;&#8203;</code>). Esto lo que hace es que ademas unir, si el visor redefine un valor se queda este ultimo.</p>
</li>
</ol>
</div>
</li>
<li>
<p>El siguiente paso es crear la configuracion base. Esta configuracion tiene todo el WebPack configurado para TypeScript, SCSS y generar los ficheros para <code>Producción</code></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>En la construccion del objeto se le injectan el directorio destino y el plugin de "Define" tener acceso a las variables de entorno</p>
</li>
<li>
<p>En el mismo "Define" se incluyen las variables de configuracion para poder leerlas, en caso de ser necesario.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Por ultimo, si la variable que indica el entorno (<code>NODE_ENV</code>) es de Desarrollo, mediante la extension se añaden todos los campos que WebPack necesita para un entorno de desarrollo (incluir mapa de ficheros/codigo, no optimizar, configuracion del servidor&#8230;&#8203;)</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>como en caso anterior, en la construccion del objeto se inyecta la url donde estan los artefactos.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_aplicacion">Aplicacion</h3>
<div class="paragraph">
<p>Como hemos visto en el <code>package.json</code> el punto de entrada de la appliacion es el fichero <code>index.js</code>, dentro de la carpeta src.
Este codigo debe instanciar una clase que extienda BaseApp e implementar una serie de metodos para seguir el proceso general siguiente:</p>
</div>
<div class="imageblock text-center text-center">
<div class="content">
<img src="media/Applicacion.svg" alt="Proceso Aplicacion">
</div>
<div class="title">Figure 7. Componentes Vision General</div>
</div>
<div class="paragraph">
<p>Como se ve el diagrama hay 3 grupos:
* App: son los objetos que debe proporcinar la applicacion
* Core: Son los objetos que proporciona el core (solo representado un resumen, para explicar)
* times.js: un ejemplo de un artefacto del <code>NcWebMapper</code>, necesario para la inicializacion.</p>
</div>
<div class="paragraph">
<p>La aplicacion como minimo debe tener un <code><strong>Index</strong></code> (invocado al iniciar) y una Clase <code><strong>VisorApp</strong></code> que extienda de <code><strong>BaseApp</strong></code>. Para facilitar la gestion de los mismos y disociar la funcionalidad de los datos a mostrar, se ha creado una clase <code><strong>DataService</strong></code> que se recomienda proporcionar tambien.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Data service no es invocado por el <code>core</code>, pero permite relacionar opciones de la UI con las variables de los NetCDF. Y en futuras versiones se estudiara si merece la pena que el acceso al mismo forme parte del <code>core</code>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_index">Index</h4>
<div class="listingblock">
<div class="title">extreme-precipitation-monitor/src/index.ts</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">import { AppEPM } from "./App"; <i class="conum" data-value="1"></i><b>(1)</b>
export const app=AppEPM.getInstance() <i class="conum" data-value="2"></i><b>(2)</b>

app.configure()  <i class="conum" data-value="3"></i><b>(3)</b>
    .then((res)=&gt;{app.render()}) <i class="conum" data-value="4"></i><b>(4)</b>
    .catch((res)=&gt;{console.error("error loading data...",res)}) <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Importamos la clase que extiende de <code>BaseApp</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Obtendremos una instancia, que seguira el patron singleton</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Ejecutamos el codigo de configuracion del visor. (que deberia ser obtener el times.js y establecer variables)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Cuando se haya terminado de configurar le notificaremos al core que renderice el html e inicie la aplicacion.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>En caso de error.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Este fichero sera muy similar para cada visor, (en realidad solo habria que cambiar el nombre de clase)</p>
</div>
</div>
<div class="sect3">
<h4 id="_visorapp">VisorApp</h4>
<div class="paragraph">
<p>El visor es la clase que extiende de BaseApp, y debe ser un singleton. Iremos viendola poco a poco</p>
</div>
<div class="sect4">
<h5 id="_singleton">Singleton</h5>
<div class="paragraph">
<p>Una clase Singleton se desarrolla para que solo haya una instancia, para ello hay que poner un codigo muy concreto;</p>
</div>
<div class="listingblock">
<div class="title">extreme-precipitation-monitor/src/App.ts</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">... <i class="conum" data-value="1"></i><b>(1)</b>
export class AppEPM extends BaseApp{ <i class="conum" data-value="2"></i><b>(2)</b>
    private static instance:AppEPM; <i class="conum" data-value="3"></i><b>(3)</b>
    private service:EpmService <i class="conum" data-value="4"></i><b>(4)</b>

    public static getInstance(): AppEPM { <i class="conum" data-value="5"></i><b>(5)</b>
        if (!AppEPM.instance) {
            AppEPM.instance = new AppEPM();
        }

        return AppEPM.instance;
    }

    private constructor(){ <i class="conum" data-value="6"></i><b>(6)</b>
        super()
        this.service=new EpmService()
    }
...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Omitidos los imports, mirar el fichero</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Defincion de la clase, extendiendo <code><strong>BaseApp</strong></code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Esta va a ser la unica instancia de la clase, importante el <code>private static</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>atributos de instancia, en este caso el servicio.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Metodo publico que nos dara acceso a la instancia.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Constructor <code>private</code>, al ser privado Solo el metodo <code>getInstance()</code> tiene acceso al mismo. Tamiben es importante la llamada a <code>super()</code> para que se ejecute el constructor de <code>BaseApp</code></td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Al hacer la clase como singleton nos permite, si lo necesitaramos, localizarla sin guardala en el objeto <code>window</code>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_configuración">Configuración</h5>
<div class="paragraph">
<p>La configuracion del visor se realiza en en el metodo <code>configure()</code>. Como se puede ver obtiene el Times.JS de manera asyncrona y cuando lo tiene configura el estado y la UI.</p>
</div>
<div class="listingblock">
<div class="title">extreme-precipitation-monitor/src/App.ts</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">...
    public async configure():Promise&lt;AppEPM&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

        let timesJs= await loadTimesJs(); <i class="conum" data-value="2"></i><b>(2)</b>
        this.setTimesJs(timesJs,"all_spei_0.5") <i class="conum" data-value="3"></i><b>(3)</b>

        let vars = this.service.getVars() <i class="conum" data-value="4"></i><b>(4)</b>
        this.state.varName=vars[0]; <i class="conum" data-value="4"></i><b>(4)</b>
        let selections=this.service.getSelections(this.state) <i class="conum" data-value="4"></i><b>(4)</b>
        this.state.selection=selections[0] <i class="conum" data-value="4"></i><b>(4)</b>
...
        this.getMenuBar().setTitle("Extreme Precipitations Monitor") <i class="conum" data-value="5"></i><b>(5)</b>
        this.getSideBar().setSupportValues(this.service.getRenderers()) <i class="conum" data-value="5"></i><b>(5)</b>
...
        return this; <i class="conum" data-value="1"></i><b>(1)</b>
    }
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Al usar el getTimes de manera Asyncrona, creamos el metodo como <code>async</code> y devolvemos la propia instancia o <code>this</code>, (aunque en la firma estamos obligados a deolver un <code>Promise</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Usamos el await para cargar el artefacto <code>Times.js</code>, esto bloquea la ejecucion hasta que de forma asincrona lo recibamos.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Una vez recibida, invocamos al metodo de la <code>BaseApp</code> para que ajuste el times.js al estado que necesita.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Utilizamos el servicio para personalizar el estado</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Por ultimo configuramos algunas cosas de la UI</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_eventos_a_implementar">Eventos a implementar</h5>
<div class="paragraph">
<p>Los eventos son funciones que se han definido en <code>BaseApp</code> que se corresponden con acciones del usuario. Algunas son  responsabilidad de <code>BaseApp</code> otras de <code>VisorApp</code> y para algunas se ha dejado una implementacion vacia en <code>BaseApp</code></p>
</div>
<div class="listingblock">
<div class="title">Firma de las funciones de eventos</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">    // Responsabilidad de BaseApp <i class="conum" data-value="1"></i><b>(1)</b>
    onDragStart(event:CsMapEvent): void{...}
    public onLlDataLoaded(data:CsLatLongData){...}
    onClick(event: CsMapEvent): void {...}
    public onMouseMoveEnd(event: CsMapEvent): void{...}
    public downloadNc():void{...}
    public downloadPoint():void{...}
    public downloadPointOptions():void{...}
    public showGraph(){...}

    // Con implementacion por defecto <i class="conum" data-value="2"></i><b>(2)</b>
    onMapInited(): void {...}
    onMapLoaded(): void {...}
    public spatialSelected(index: number, value?: string, values?: string[]):void {...}

    // Responsabilidad de VisorApp <i class="conum" data-value="3"></i><b>(3)</b>
    public abstract varSelected(index: number, value?: string, values?: string[]): void;
    public abstract selectionSelected(index: number, value?: string, values?: string[]): void;
    public abstract selectionParamChanged(param: number): void;
    public abstract getLegendValues():number[];</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Son los eventos que en todos los visores deben comportarse igual. En caso de necesidad, un visor puede sobreescribir el metodo si realmente es necesario.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Son metodos que el Visor deberia cambiar pero se puede definir un comportamiento por defecto.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Son los metodos que dependen del visor.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Los eventos de la clase <code>BaseApp</code> no vamos explicarlos en este apartado. Las implementaciones por defecto, son sin efecto (vacias, comentado un log) y simplemente las comentamos, no las veremos.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><strong>onMapInited</strong></code>: es invocado cuando se crea el mapa, por codigo en el <code>core</code></p>
</li>
<li>
<p><code><strong>onMapLoaded</strong></code>:  Es la propia libreria de mapas que envia dicho evento cuando se terminado de cargar.</p>
</li>
<li>
<p><code><strong>spatialSelected</strong></code>: se invoca cuando se cambia la opcion espacial en la UI (1). Por ahora no hace nada</p>
</li>
<li>
<p><code><strong>varSelected</strong></code>: se invoca cuando se cambia la opcion variable en la UI (2). Debe moficar el estado para que <code>state.varId</code> apunte al id de la variable a mostrar (y el resto de campos necesarios, asociados a la variable)</p>
</li>
<li>
<p><code><strong>selectionSelected</strong></code>: se invoca cuando se cambia la opcion seleccion en la UI (3). Debe moficar el estado para que <code>state.selection</code> y <code>state.selectionParam</code> puedan filtrar los datos (Funcionalidad nueva)</p>
</li>
<li>
<p><code><strong>selectionParamChanged</strong></code>: se invoca cuando se cambia el parametro manual de seleccion (4). Debe moficar el estado para que <code>state.selection</code> y <code>state.selectionParam</code> puedan filtrar los datos (Funcionalidad nueva)</p>
</li>
<li>
<p><code><strong>getLegendValues</strong></code>: Se invoca cuando se refresca la ui para componer la leyenda y el SLD de WMS que pinta los colores de los datos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Aqui representamos el origen de los eventos en una captura de la pantalla:</p>
</div>
<div class="imageblock text-center text-center">
<div class="content">
<img src="images/esqueleto/OrigenesEventos.png" alt="][&quot;Origenes de Los eventos&quot;">
</div>
<div class="title">Figure 8. Origines de los evento</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dataservice">DataService</h4>
<div class="paragraph">
<p>El objeto DataService esta pensado para facilitar la integracion de la UI con la estructura de los artefactos NcWebMapper.</p>
</div>
<div class="sect4">
<h5 id="_soporte_espacial">Soporte Espacial</h5>
<div class="paragraph">
<p>El soporte Espacial son los renderizadores que se usaran, o bien un raster generado (en el JS o por WMS) o bien agregaciones vectoriales con colores.</p>
</div>
<div class="listingblock">
<div class="title">extreme-precipitation-monitor/src/EpmService.ts</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">import { CsViewerData } from "anemui-core/src/data/CsDataTypes";
...
export class EpmService {
    public getRenderers(): string[] { <i class="conum" data-value="1"></i><b>(1)</b>
        return renderers
    }
...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Este metodo genera la lista de soporte espacial</td>
</tr>
</table>
</div>
<div class="imageblock text-center text-center">
<div class="content">
<img src="images/esqueleto/OrigenEspacial.png" alt="Origen Espacial">
</div>
<div class="title">Figure 9. Origen Espacial</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
No soportado por ahora.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_variables">Variables</h5>
<div class="paragraph">
<p>Son el nombre de Variables que se mostraran en el listado de variables</p>
</div>
<div class="listingblock">
<div class="title">extreme-precipitation-monitor/src/EpmService.ts</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">...
    public getVars(): string[] {
        return ["24H Intensity", "48H Intensity", "Return Period", "Event Magnitude", "Event Duration"]
    }
...</code></pre>
</div>
</div>
<div class="imageblock text-center text-center">
<div class="content">
<img src="images/esqueleto/Variables.png" alt="Variables">
</div>
<div class="title">Figure 10. Variables</div>
</div>
</div>
<div class="sect4">
<h5 id="_seleccion">Seleccion</h5>
<div class="paragraph">
<p>La seleccion es un parametro de filtrado textual. Aunque tambien se puede ver como segundo nivel dentro de las variables. Sus valores dependen de la variable seleccionada, pero el metodo recibe el estado completo, por lo que se puede hacer depener de más opciones</p>
</div>
<div class="listingblock">
<div class="title">extreme-precipitation-monitor/src/EpmService.ts</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">...
    public getSelections(state: CsViewerData): string[] {
        let ret: string[]
        switch (state.varName) { <i class="conum" data-value="1"></i><b>(1)</b>
            case "24H Intensity":
            case "48H Intensity":
                ret = ["10mm", "25mm", "50mm", "100mm", "200mm"]
                break;
            case "Return Period":
                ret = ["1 year", "5 years", "10 years", "25 years", "50 years"]
                break;
... <i class="conum" data-value="2"></i><b>(2)</b>
        }

        ret.push("Custom") <i class="conum" data-value="3"></i><b>(3)</b>
        return ret;
    }
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Switch segun el nombre de la variable (estara el mismo texto que alguna de las opciones de <code>getVars</code>, concretamente la seleccionada)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Omitimos el resto de opciones, puede verse el codigo para todas</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>En cualquier caso añadimos una opcion Custom.</td>
</tr>
</table>
</div>
<div class="imageblock text-center text-center">
<div class="content">
<img src="images/esqueleto/Seleccion24h.png" alt="Seleccion de 24h">
</div>
<div class="title">Figure 11. Seleccion disponible de 24h</div>
</div>
</div>
<div class="sect4">
<h5 id="_relacion_con_varid_netcdf">Relacion con varId (NetCDF).</h5>
<div class="paragraph">
<p>La relacion con el <code>varId</code> del <code>times.js</code>, se establece en la funcion <code>getVarId</code> esta funcion debe devolver el ID dentro del NetCDF de la variable a mostrar.</p>
</div>
<div class="listingblock">
<div class="title">extreme-precipitation-monitor/src/EpmService.ts</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">...
    public getVarId(state: CsViewerData): string {
        switch (state.varName) { <i class="conum" data-value="1"></i><b>(1)</b>
            case "24H Intensity":
            case "48H Intensity":
            case "Return Period":
            case "Event Magnitude":
            case "Event Duration":
            default: <i class="conum" data-value="2"></i><b>(2)</b>
                return "all_spei_0.5"
        }
    }
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Switch segun el nombre de la variable (estara el mismo texto que alguna de las opciones de <code>getVars</code>, concretamente la seleccionada)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>En este caso para cualquier caso devolvemos siempre el mismo ID, Recibimos todo el estado, por lo que se podria hacer que dependiera de la seleccion.</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
En esta version no tenemos todavia el DataSet con los datos de precipitaciones extremas, en realidad estamos usando el de monitor de sequias para desarrollo.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Se ha dejado un switch como ejemplo, este caso se podria solucionar con una linea de return
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_filtrado_de_datos">Filtrado de Datos</h5>
<div class="paragraph">
<p>Para esta nueva version del visor se ha querido incluir una nueva funcionidad de filtrado de datos, de tal forma que se muestren solo una serie de datos.</p>
</div>
<div class="paragraph">
<p>Por ejemplo para el visor de precipitaciones extremas, mostrar solo los puntos/zonas que hayan superado al menos 20mm de precipicion, y los que sean de menos sean transparentes.</p>
</div>
<div class="paragraph">
<p>La UI debe mostrar una seleccion de opciones por defecto y en algunos casos permitir que se sea personalizable. Para ello el Servicio de Datos debe implementar unos pocos metodos:</p>
</div>
<div class="listingblock">
<div class="title">extreme-precipitation-monitor/src/EpmService.ts</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">...
    public getSelectionParam(state:CsViewerData):number{ <i class="conum" data-value="1"></i><b>(1)</b>

        return parseFloat(state.selection)/10; // to see something divide by ten
    }

    public isSelectionParamEnabled(state:CsViewerData){ <i class="conum" data-value="2"></i><b>(2)</b>
        return ("Custom" == state.selection)
    }
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>getSelectionParam</code> debe devolver un numero que sera e minimo a mostrar</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>isSelectionParamEnabled</code> Sirve para indicar si el usuario puede o no introducir parametros a mano. (Habilitando o deshabilitando la ediccion del campo de texto)</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ambos metodos reciben el estado completo por lo que se pueden hacer filtrados muy especilizados.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
El filtrado ahora mismo solo soporta poner un limite inferior. Esta en estudio si hay que modificar todo el filtrado para soportar mas opciones, segun los visores a desarrollar
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Recordad que el DataSet utilizado son las sequias y los valores estan en un rango [-2.3, 2.3] (aproximadamente) pero las opciones mostradas son para el monitor de precipitaciones extremos ("10mm", "25mm", "50mm",&#8230;&#8203;).
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Aprovechamos que <code>parseFloat</code> omite el texto y nos devuelve un float valido para componer el valor de filtrado. Simplemente lo divimos para 10, asi queda un resultado que, al menos de inicio, se vea algo.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_entorno_de_ejecución">Entorno de Ejecución</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Los visores se han desarrollado para que se use Docker y sus volumenes para servir tanto los datos como los propios visores.</p>
</div>
<div class="sect2">
<h3 id="_vision_general">Vision General</h3>
<div class="paragraph">
<p>Dentro de la infraestrucutra del LCSC se ha decidido usar un servidor NFS, llamado <code>genoma</code>, para almacenar todos los datos. Y ademas se tiene un ordenador frontal (<code>sc-frontal</code>) que es el que esta sirviendo de publicador web y securizador de las conexiones. Este frontal contacta con otros ordenadores que son los que sirve tanto las paginas html de los visores como los datos. Estos ordenadores contienen los servicios como Docker-Compose.</p>
</div>
<div class="imageblock text-center text-center">
<div class="content">
<img src="media/ee_vision_general.svg" alt="Vision Alto Nivel">
</div>
<div class="title">Figure 12. Vision General</div>
</div>
<div class="sect3">
<h4 id="_sc_frontal">sc-frontal</h4>
<div class="paragraph">
<p>Este nodo, solo tiene un apache funcionando y es el que realiza las rediecciones pertinentes y <strong>aplica la seguridad (SSL y Autenticacion)</strong></p>
</div>
<div class="listingblock">
<div class="title">apache.conf</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-apache hljs" data-lang="apache">RewriteEngine on
RewriteRule ^/etm-dev$ /etm-dev/ [R] <i class="conum" data-value="1"></i><b>(1)</b>
...
    &lt;Location "/etm-dev/"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
        AuthType Basic
        AuthName "Restricted Content"
        AuthUserFile [AuthFile]
        Require valid-user
        ProxyPass "http://sc-aemet-1:8090/etm-dev/"
    &lt;/Location&gt;
...
    &lt;Location "/etm/"&gt; <i class="conum" data-value="2"></i><b>(2)</b>
        AuthType Basic
        AuthName "Restricted Content"
        AuthUserFile [AuthFile]
        Require valid-user
        ProxyPass "http://sc-aemet-prod:8090/etm/"
    &lt;/Location&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Ejemplo para el visor ETM</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Lo mismo para la version prod</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_sc_aemet_1">sc-aemet-1</h4>
<div class="paragraph">
<p>Este nodo ejecuta los jobs que crean los artefactos y publica los diferentes servicios de cada visor.</p>
</div>
<div class="paragraph">
<p>Tiene un compoente 'Frontal Dev' que algutina todos los visores y los publica mediante HTTP. Es un 'nginx' que hace proxy reverso</p>
</div>
<div class="listingblock">
<div class="title">docker-compose.yaml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">version: "3.9"
networks:
  sc-net: <i class="conum" data-value="1"></i><b>(1)</b>
    name: sc-net
    driver: bridge
include: <i class="conum" data-value="2"></i><b>(2)</b>
  - docker-compose.etm.yaml
    ...
volumes:
  sc-nc: <i class="conum" data-value="3"></i><b>(3)</b>
    driver_opts:
      type: "nfs"
      o: "addr=genoma,bg,soft,nolock"
      device: ":[ruta]/data"

services:
  frontal-server: <i class="conum" data-value="4"></i><b>(4)</b>
    image: nginx:alpine
    ports:
      - 8090:80
    restart: unless-stopped
    volumes:
      - ./frontal.conf:/etc/nginx/conf.d/default.conf
    networks:
      - sc-net
    depends_on:
      - etm-web-server
      - etm-artifacts-server
        ...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Primero se define una red para poder comunicar todos los servicios</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Cada visor tiene su propio 'docker-compose.yaml' para facilitar la legibilidad</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>El volumen de datos de entrada se define en este fichero y esta usado por los jobs.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>el servicio frontal algutinador, que como se puede ver esta publicado en el 8090 y depende del resto de servicios.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Por su parte cada visor tiene un Yaml similar al de ETM.</p>
</div>
<div class="listingblock">
<div class="title">docker-compose-etm.yaml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">volumes:
  etm-artifacts:
    driver_opts: <i class="conum" data-value="1"></i><b>(1)</b>
      type: "nfs"
      o: "addr=genoma,bg,soft,nolock"
      device: ":[ruta]/web/etm"
services:
  etm-job: <i class="conum" data-value="2"></i><b>(2)</b>
    image: lcsc-r:latest
    volumes:
      - [Ruta Scripts etm]/etm.R:/data/etm.R:ro
      - [Ruta Scripts etm]/functions.R:/data/functions.R:ro
      - sc-nc:/data/nc:rw <i class="conum" data-value="3"></i><b>(3)</b>
      - etm-artifacts:/data/out:rw <i class="conum" data-value="3"></i><b>(3)</b>
    command: Rscript /data/etm.R
    #command: ls /data

  etm-artifacts-server: <i class="conum" data-value="4"></i><b>(4)</b>
    image: nginx:alpine
    # ports:
    #   - 8091:80
    restart: unless-stopped
    volumes:
      - etm-artifacts:/usr/share/nginx/html:ro <i class="conum" data-value="4"></i><b>(4)</b>
    networks:
      - sc-net

  etm-web-server: <i class="conum" data-value="5"></i><b>(5)</b>
    image: lcsc-viewer-extreme-temperature-monitor:build <i class="conum" data-value="5"></i><b>(5)</b>
    # ports:
    #   - 8092:80
    restart: unless-stopped
    networks:
      - sc-net</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Cada visor crea un volumen propio con una conexion NFS a su propio almacen</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>El job es el encargado de procesar los NetCDF procesados y se encargan de generar el times.js y las versiones chunkeadas (en tiempo y espacio) de los mismos.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Si nos fijamos utiliza el volumen de los datos y tambien el del propio visor por que luego el servicio lo publicara</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Servicio nginx que publica los artefactos generados por el job.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Este servicio se genera desde el codigo del visor. Creando una imagen Docker. La imagen dev se crea de la rama main.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_sc_aemet_prod">sc-aemet-prod</h4>
<div class="paragraph">
<p>Para la version productiva, los ficheros son similares pero atendiendo a las siguientes caracteristicas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En genoma hay una copia de la carpeta web, con los artefactos generados (y los nc-descargables)</p>
<div class="ulist">
<ul>
<li>
<p>Tanto para prod, como para proto-1</p>
</li>
</ul>
</div>
</li>
<li>
<p>No tiene los Jobs (ya han sido generados)
Las imagenes docker se generan de otras ramas</p>
<div class="ulist">
<ul>
<li>
<p>Para la version Prod, las imagenes se generan de la rama stable</p>
</li>
<li>
<p>Para la version Proto, las imagenes se generan de la tag proto-1</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_imagenes_docker">Imagenes Docker</h3>
<div class="paragraph">
<p>Se utilizan varias imagenes docker, simplificadas a dos tipo, la imagen de R y las imagenes de los visores</p>
</div>
<div class="sect3">
<h4 id="_lcsc_r">LCSC-R</h4>
<div class="paragraph">
<p>Dentro del repositorio <code>MachineScripts</code> esta la carpeta <code>DockerImages/R_DevContainer</code>, con un DockerFile que genera una imagen de R compatible con DevContainers y todas las librerias que necesitamos.</p>
</div>
<div class="paragraph">
<p>Ejecutar el commando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker build . -t lcsc-r:latest \
 --build-arg VARIANT=4.3 \
 --build-arg BASE_IMAGE=r-ver \
 --build-arg HDF5_BRANCH=chunk_functions \
 --build-arg NCWEBMAPPER_BRANCH=the_chunk_way</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una vez que termine nos habra generado la imagen docker que requieren los Jobs para genera los artefactos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_imagenes_de_los_visores">Imagenes de los visores.</h4>
<div class="paragraph">
<p>En el repositorio de los visores hay <code>Dockerfile</code> que permite la generacion de una imagen docker de un visor. El resultado es un nginx al que se le inyecta en el docker build la carpeta dist del visor.</p>
</div>
<div class="paragraph">
<p>Dicha imagen tiene 3 parametros para poder generar cada visor y algunas variantes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>NODE_VERSION</strong> Por defecto <code>18-alpine</code>, es el node que se utiliza para generar la carpeta dist del visor.</p>
</li>
<li>
<p><strong>ENVIRONENT</strong> Por defecto <code>build</code> Es el commando de construccion que se ejecutara, solo pueden ser <code>build</code>, <code>build-wms</code> o <code>prod</code>.</p>
</li>
<li>
<p><strong>VIEWER</strong> Obligatorio, la carpeta del visor a generar.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Es posible hacer un 'docker build . --build-arg &#8230;&#8203;' pero para facilitar las cosas se ha creado un script <code>build.sh</code> que facilita la creacion de las imagenes. Para cada visor crea dos tags <code>[latest]</code> y <code>[git version]</code></p>
</div>
<div class="listingblock">
<div class="title">ejemplos</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./build.sh -a # crea todas las imagenes version desarrollo
./build.sh -v fire-risk-index # crea solo las imagenes de fire-risk-index version desarrollo
./build.sh -a -e prod # crea todas las imagenes version produccion (ofuscadas)
./build.sh -v fire-risk-index -e prod # crea solo las imagenes de fire-risk-index version produccion (ofuscadas)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cuando se regenere una imagen (o todas) es necesario relanzar los servicios</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jobs">Jobs</h3>
<div class="paragraph">
<p>Todos los jobs siguen el mismo esquema y lo que hacen es construir un DataFrame con el listado de ficheros necesario y para cada fichero se realizan los siguientes pasos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Creacion del chunk temporal (solo si los datos son nuevos)</p>
</li>
<li>
<p>Creacion del bin temporal (solo si el chunk temporal es nuevo)</p>
</li>
<li>
<p>Creacion del chunk XY (solo si los datos son nuevos)</p>
</li>
<li>
<p>Creacion del bin temporal (solo si el chunk XY es nuevo)</p>
</li>
<li>
<p>Preparacion estructura Times.JS (Siempre)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Finalmente se crea el times.js</p>
</div>
<div class="listingblock">
<div class="title">etm.R</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-R hljs" data-lang="R">source('data/functions.R')

# Common cfg
...

ncVars &lt;- data.frame("var"=c("tmax","tmin"),
                    "file"=c("tmax_daily_grid","tmin_daily_grid"),
                    "join"=c(TRUE,TRUE))

ncVars &lt;-rbind(ncVars,data.frame("var"="heat_wave","file"="heatwave.nc","join"=FALSE))
...

info_js &lt;- NaN

nVars &lt;- dim(ncVars)[1]
for (nc in 1:nVars)  {
  el = ncVars[nc,]
  out_file=paste0(el$file,all_suffix)
  if(el$join){
    print (paste0("Uniendo ",el$file,pen_suffix," + ",el$file,can_suffix," -&gt; ",out_file))
    join_pen_can(nc_root=nc_route,
              pen_file=paste0(el$file,pen_suffix),
              can_file=paste0(el$file,can_suffix),
              all_file=paste0(el$file,all_suffix))
  }else{
    out_file=el$file
  }
  print (paste0("Procesando: ",el$var," desde el fichero ",out_file))
  info_js &lt;- generate_etm_artifacts(nc_route,
                                  out_route, out_file,
                                  el$var, max_zoom,
                                  epsg, info_js, FALSE)
}

title &lt;- "ETM"
....

# Generamos el fichero time.js
print ("End: times.js")
result &lt;- writeJs(
  folder = out_route, infoJs = info_js, title = title,
  varNames = var_names, varTitle = var_title,
  legendTitle = legend_title, projection = projection
)
#nc_dates(365)
print("Done")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_utilidades">Utilidades</h3>
<div class="ulist">
<ul>
<li>
<p><strong>launch_jobs.sh</strong>: Este comando instuye a docker para crear los contenedores y ejecutar todos los jobs. Ojo, la maquina solo tiene memoria para procesar 1 job de chunkeo. Para lanzar un solo job se le pasa como parametro el visor: <code>./laun_jobs.sh etm</code></p>
</li>
<li>
<p><strong>launch_services.sh</strong>: Este comando instuye a docker para crear los contenedores y ejecutar todos los servicios HTTP (tanto su aglutinador como de los servicios). Como el anterior sin parametros reinicia todos y con parametro solo en indicado. Hay que ejecutarlo si se regeneran las imagenes de los visores.</p>
</li>
<li>
<p><strong>buildFrontalConf.sh</strong>: Este script genera la configuracion nginx del servicio aglutinador, se ejecuta <code>./buildFrontalConf.sh &gt; frontal.conf</code>. Si se añade algun visor o hay que hacer algo en la configuracion</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_desarrollo_del_anemui_core">Desarrollo del AnemUI-core</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Desde la creacion del repositorio AnemUI se ha separado el Core de los visores, por lo que el workspace de los visores no contienen el core. Siendo el core una depencia más disponible para más proyectos.</p>
</div>
<div class="paragraph">
<p>Esto nos obliga a tener que hacer una gestion y publicacion de los paquetes, pero nos permite aislar codigos y reutilizar el core en todos nuestros visores.</p>
</div>
<div class="paragraph">
<p>Par poder modificar el core debemos bajarnos el codigo y "engañar" a <code>node_modules</code> para tener el codigo disponible y reconocible .</p>
</div>
<div class="sect2">
<h3 id="_modificacion_espacio_de_trabajo">Modificacion Espacio de trabajo</h3>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Crea antes una rama tanto en AnemUI (<strong>&lt;rama_core&gt;</strong>) como en tu visor (<strong>&lt;rama_visor&gt;</strong>) ya sea en la pagina de github o por <code>cli</code>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ git checkout -b &lt;rama&gt;
$ git push -u origin &lt;rama&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Una vez que tengamos las ramas solo ejecutaremos lo siguiente</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ cd [ruta_al_visor] <i class="conum" data-value="1"></i><b>(1)</b>
# Cambiamos a la rama visor (cli) <i class="conum" data-value="2"></i><b>(2)</b>
$ git fetch
$ git checkout -b &lt;rama_visor&gt;
$ git pull

# Modificamos el node_modules <i class="conum" data-value="3"></i><b>(3)</b>
$ npm i
$ rm -r node_modules/@lcsc
$ git clone git@github.com:lcsc/AnemUI.git -b &lt;rama_core&gt;
$ mkdir node_modules/@lcsc
$ ln -s ../../AnemUI/anemui-core  node_modules/@lcsc/anemui-core
$ ln -s ../../AnemUI/anemui-test  node_modules/@lcsc/anemui-test

# Nos aseguramos que AnemUI es ignorado
$ echo AnemUI &gt;&gt; .gitignore <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nos situamos el en el visor</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Pasamos el WorkDir a la rama nueva del visor. Podemos hacerlo en el editor</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Modificacion en si del node modules</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Ejecutar solo una vez, o si al hacer <code>git status</code> aparecen cambios de AnemUI</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A partir de este momento tenemos en nuestra carpeta del visor el codigo del core y lo podemos modificar a voluntad.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Ahora hay dos repositorios que hay que actualizar, vs_code puede subir a los dos, pero si se quiere usar el cli hay que ejecutar
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Repo Visor
$ git add ....
$ git commit ....
$ git push
# Repo anemui, hacer cd y los anteriores o
$ git -c AnemUI add ....
$ git -c AnemUI commit ....
$ git -c AnemUI push</code></pre>
</div>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Es posible usar submodulos de git, pero complica un poco la subida de codigo al repo del core.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_publicacion_automatica_de_cambios">Publicacion Automatica de cambios.</h3>
<div class="paragraph">
<p>Tenemos un jenkins que se encarga de que cada vez que haya cambios en la <strong>rama main</strong> del repositorio ejecute el proceso de publicacion en nuestro <a href="https://mirror.lcsc.csic.es/#browse/browse:anemui">nexus</a></p>
</div>
<div class="paragraph">
<p>Como Se tiene que desarrollar en una rama propia lo que hay que hacer es Mergear el codigo a <strong>main</strong>. Se debe ir a la pagina de <a href="https://github.com/lcsc/AnemUI/pulls">github</a> y crear un pull request. Alguien dara el visto bueno y lo integrara en la rama y se generara el artefacto en el nexus.</p>
</div>
<div class="paragraph">
<p>Cuando ya este el desplegado (Quien de el visto bueno, lo notificara) habra que ejecutar <code>npm upgrade</code> para que se actualicen las dependencias a la nueva version.</p>
</div>
</div>
<div class="sect2">
<h3 id="_publicacion_manual_de_cambios">Publicacion Manual de cambios</h3>
<div class="paragraph">
<p>En el caso de querer hacer manualmente la publicacion (por ejemplo falle el jenkins) los pasos que hay que hacer son los siguientes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">npm login --scope=@lcsc --registry=https://mirror.lcsc.csic.es/repository/anemui/
# user: anemui
# pw: la misma que la wiki
npm run setVersion
npm install
npm publish --workspaces --if-present
npm run setVersionFile #deshace los cambios de version</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Estamos haciendo versiones <strong>SNAPSHOT</strong>, por lo que se ejecuta setVersion para modificarla. esto modifica los json del versiones, es necesario revertir los cambios al final, para que siga funcionado. Por lo que <strong>ANTES</strong> de nada nos aseguraremos de tener todos los cambios comiteados
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estabiliacion_de_version">Estabiliacion de Version.</h3>
<div class="paragraph">
<p>Para cerrar una version <strong>[VERSION]</strong> y dejar main preparado para la <strong>[NEXT_VERSION]</strong> los pasos a seguir son:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Ya cerrados y comitados todos los cambios

echo [VERSION] &gt;version
npm run setVersion
npm install

#npm login .... #Si es necesario
npm publish --workspaces --if-present

git add .
git commit -m "Version [VERSION]"
git push
git tag -a [VERSION] -m "Version [VERSION]"
git push --tags

echo [NEXT-VERSION]-SNAPSHOT &gt;version
npm run setVersionFile #Lo deja preparado
git commit -m "SNAPSHOT para [NEXT_VERSION]"
git push</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pruebas_de_software">Pruebas de software</h3>
<div class="paragraph">
<p>Se ha realizado una serie de Pruebas de integración para probar las interacciones entre componentes de los distintos visores, y validar de una manera eficiente que el código de la aplicación funciona como se pretende. Para crear un marco de automatización de dichas pruebas se ha elegido Selenium + Mocha</p>
</div>
</div>
<div class="sect2">
<h3 id="_mocha">Mocha</h3>
<div class="paragraph">
<p>Mocha es un entorno de prueba de JavaScript para programas de Node.js muy popular que nos permite organizar nuestros casos de prueba y se encarga de ejecutarlos. Ofrece compatibilidad con navegadores, pruebas asincrónicas, informes de cobertura de pruebas y el uso de cualquier biblioteca de aserciones. Para incorporarlo al proyecto y que sea ejecutable desde cada visor, se debe instalar y actualizar el comando de prueba "test" en el package.json de cada uno de ellos para que contenga el script ejecutable de Mocha.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">$ npm install mocha</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">package.json</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">"scripts": {
    "test": "mocha (+ algunas opciones)"
  },</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por ejemplo, El package.json del Sistema de información agrometeorológica tiene este aspecto:</p>
</div>
<div class="listingblock">
<div class="title">package.json</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "name": "aam-monitor",
  "version": "0.0.1",
  "description": "Agro-meteorology Monitor",
  "main": "src/index.ts",
  "devDependencies": {},
  "scripts": {
    "build": "NODE_ENV=development webpack",
    "prod": "NODE_ENV=production webpack",
    "build-wms": "NODE_ENV=wms webpack",
    "watch": "webpack --watch",
    "start": "webpack serve --open",
    "dev": "NODE_ENV=development webpack serve --open",
    "dev-wms": "NODE_ENV=developmentWms webpack serve --open",
    "test":"mocha  --timeout 10000"
  },
  /// .......
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sin embargo, Mocha por sí solo no verifica el comportamiento de nuestro código, para ello necesitamos una herramienta que nos permita grabar/reproducir las pruebas, ahí entra Selenium.</p>
</div>
</div>
<div class="sect2">
<h3 id="_selenium">Selenium</h3>
<div class="paragraph">
<p>Selenium es una herramienta de automatización de pruebas también muy popular y ampliamente utilizada en el campo del desarrollo de software. Permite a los desarrolladores y testers simular interacciones de un usuario con una aplicación web, lo que facilita la detección de errores y la validación de la funcionalidad.</p>
</div>
<div class="paragraph">
<p>Se ha preferido frente a otras plataformas como Cypress, Playwright o WebdriverIO por su compatibilidad con las herramientas de desarrollo utilizadas en la plataforma (Nodejs/npm, Javascript), por su facilidad de uso y por existir ya experiencia previa en el equipo.</p>
</div>
<div class="paragraph">
<p>La instalación de Selenium Webdriver es sencilla si previamente tenemos Node.js y npm instalados, simplemente basta con ejecutar el siguiente código en el terminal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">$ npm install selenium-WebDriver</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una vez instalado Selenium WebDriver, en el archivo package.json del raíz debería aparecer el paquete Selenium WebDriver instalado entre las dependencias del proyecto:</p>
</div>
<div class="listingblock">
<div class="title">package.json</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">"dependencies": {

    "selenium-webdriver": "^4.17.0"

  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>La estructura básica del archivo de pruebas realizado con Selenium consta de:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js"><i class="conum" data-value="1"></i><b>(1)</b>
const {Browser} = require('selenium-webdriver');
const {suite} = require('selenium-webdriver/testing');
const firefox = require('selenium-webdriver/firefox');

suite(function (env) {
  describe('Título del conjunto de pruebas', function () {
    let driver;

     <i class="conum" data-value="2"></i><b>(2)</b>
    before(async function () {
      let options = new firefox.Options();
      driver = await env.builder() <i class="conum" data-value="3"></i><b>(3)</b>
        .setFirefoxOptions(options)
        .build();
    });

    <i class="conum" data-value="4"></i><b>(4)</b>
    after(async () =&gt; await driver.quit());

    it('Título de la prueba 1', async function () {
        await driver.get('https://servicios-climaticos.pti-clima.csic.es/amm-dev/'); <i class="conum" data-value="5"></i><b>(5)</b>
      ///  Aquí va el código del test 1 <i class="conum" data-value="6"></i><b>(6)</b>
      ........
    });

    it('Título de la prueba 2', async function () {
        await driver.get('https://servicios-climaticos.pti-clima.csic.es/amm-dev/'); <i class="conum" data-value="5"></i><b>(5)</b>
      ///  Aquí va el código del test 2 <i class="conum" data-value="6"></i><b>(6)</b>
    });

    ....

  });
}, { browsers: [Browser.FIREFOX]});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Carga de las librerías necesarias</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>before: Inicializa el driver, en este caso con Firefox como navegador</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Conexión al navegador</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Finaliza el driver</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>after: Inicializa la web</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>it: Ejecuta el test</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_estructura_del_código_de_pruebas">Estructura del código de pruebas</h3>
<div class="paragraph">
<p>Siguiendo la estructura de la aplicación, se han centralizado las pruebas en un código común a todos los visores donde se han reunido todos los test a realizar, accesible desde cada visor a través de un pequeño script alojado en la carpeta correspondiente a cada uno de ellos, y en el que se inicializan los parámetros específicos para poder probarlos.</p>
</div>
<div class="paragraph">
<p>Así, en la estructura de directorios de la aplicación:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>En el raíz se ha añadido una carpeta "test" donde está el archivo principal "test.js" que ejecuta las pruebas. Todo el código de este archivo se ha agrupado en la clase csTest, siendo el método performTest el encargado de ejecutar las pruebas.</p>
</li>
<li>
<p>Dentro de cada visor se ha incluido una estructura idéntica: en una carpeta también llamada "test", el respectivo script de arranque "test.js". Por ejemplo, en el visor de</p>
</li>
<li>
<p>Se ha configurado el archivo principal como un paquete de Nodejs para que pueda ser importado desde cada unos de los archivos de los visores</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">test/test.js (Clase csTest)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">// --- IMPORTACIÓN DE LIBRERÍAS NECESARIAS
const VAR_USR = 'aemet';
const VAR_PWD = 'pticlima';
const VAR_WEB_DOMAIN = "servicios-climaticos.pti-clima.csic.es/";
///-- OTRAS VARIABLES Y CONSTANTES QUE NECESITAMOS

class csTest {

// --- OTROS MÉTODOS

    performTest(params, testGraph = true) {
        // --- INICIALIZACIÓN DE CONSTANTES NECESARIAS
        const serviceCode = params["serviceCode"];

        suite((env) =&gt; {
            describe('Tests - ' + serviceFolder, function () {
                // --- INICIALIZACIÓN DE OTRAS PROPIEDADES
                const webPage = VAR_WEB_DOMAIN + serviceCode + "-dev/";

                before(async function () {
                   // ---- INICIALIZACIÓN DEL DRIVER
                });

                after(async () =&gt; await driver.quit());  // --- DESCONEXIÓN DEL DRIVER

                it(VAR_TEST_1, async () =&gt; {
                    this.timeout(0);
                    if (browserName == 'chrome') {
                        const connection = await driver.createCDPConnection('page');
                        await driver.register(VAR_USR, VAR_PWD, connection);
                        await driver.get('https://' + webPage);
                    } else {
                        await driver.get('https://' + VAR_USR + ':' + VAR_PWD + '@' + webPage);
                    }
                    ///------------  TEST 1
                });

                it(VAR_TEST_2, async () =&gt; {
                    if (browserName == 'chrome') {
                        const connection = await driver.createCDPConnection('page');
                        await driver.register(VAR_USR, VAR_PWD, connection);
                        await driver.get('https://' + webPage);
                    } else {
                        await driver.get('https://' + VAR_USR + ':' + VAR_PWD + '@' + webPage);
                    }
                    ///------------  TEST 2
                });
            }

          });
        }, { browsers: [Browser.CHROME, Browser.FIREFOX] });
    }
}

module.exports = csTest;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_método_it">Tests (método "it")</h3>
<div class="paragraph">
<p>Cada unos delos tests está englobado dentro de un método "it" de la suite selenium-webdriver. De modo que para añadir nuevos test, habría que copiar una estructura it de las ya codificadas y modificar su contenido. (Se pueden ponerntodos los test seguidos sin necesidad de utilizar esta funcionalidad, el método "it" lo que hace es organizar la ejecución)</p>
</div>
<div class="paragraph">
<p>El código que debe permanecer común a todas ella es el de conexión con la URL a testear, se ve que es diferente según testeemos en chrome o en el resto de navegadores. Esto es porque en nuestro caso estamos utilizando la configuración de Apache para que pida user/password para permitir acceder a la aplicación. Durante las pruebas, de manera empírica se comprobó que la manera de autenticar una URL con esta característica varía según el navegador. Esta es la razón de ese código. (ver <a href="https://www.browserstack.com/docs/automate/selenium/basic-http-authentication" class="bare">https://www.browserstack.com/docs/automate/selenium/basic-http-authentication</a>. Para la autenticación con Chrome ver <a href="https://rajendraak.medium.com/chrome-devtools-protocol-with-selenium-e9ffaca4b0f4" class="bare">https://rajendraak.medium.com/chrome-devtools-protocol-with-selenium-e9ffaca4b0f4</a>)</p>
</div>
<div class="paragraph">
<p>Selenium dispone de un repositorio en Github con ejemplos de script en varios lenguales de programación. De ahí se puede sacar inspiración para futuros tests <a href="https://github.com/SeleniumHQ/seleniumhq.github.io/blob/trunk/examples/javascript/test/getting_started/openFirefoxTest.spec.js" class="bare">https://github.com/SeleniumHQ/seleniumhq.github.io/blob/trunk/examples/javascript/test/getting_started/openFirefoxTest.spec.js</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_utilización_de_la_clase_cstest_desde_los_script_de_cada_visor">Utilización de la clase csTest desde los script de cada visor</h3>
<div class="paragraph">
<p>El código desarrollado para las pruebas se ha integrado en la estructura de la plataforma en forma de paquete de Nodejs, de modo que pueda ser utilizado importándolo desde cada script individual.</p>
</div>
<div class="paragraph">
<p>Para tal fin, se ha generado el package.json de la carpeta test raíz,</p>
</div>
<div class="listingblock">
<div class="title">test/package.json</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "name": "common-test",
  "version": "0.0.1",
  "description": "Climatic Services Test Suite",
  "main": "src/index.ts",
  "devDependencies": {},
  "scripts": {
    "test":"mocha  --timeout 10000"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/lcsc/VisorServiciosClimaticos.git"
  },
  "author": "LCSC",
  "license": "GPL-3.0",
  "bugs": {
    "url": "https://github.com/lcsc/VisorServiciosClimaticos/issues"
  },
  "browser": {
    "fs": false,
    "os": false,
    "path": false
  },
  "homepage": "https://github.com/lcsc/VisorServiciosClimaticos#readme"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Posteriormente se ha instalado como un paquete de Node.js con el nombre "common-test". Así ya se puede importar el script desde cada visor para poder ser utilizado. Por ejemplo, en el test.js del Sistema de información agrometeorológica:</p>
</div>
<div class="listingblock">
<div class="title">agrometeorology-monitor/test/test.js</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">const csTest = require('common-test/test'); <i class="conum" data-value="1"></i><b>(1)</b>

let test = new csTest; <i class="conum" data-value="2"></i><b>(2)</b>

const serviceCode   = "amm"; <i class="conum" data-value="3"></i><b>(3)</b>
const serviceFolder = "agro-meteorology-monitor";
const serviceTitle  = "Sistema de información agrometeorológica";
const dropDownId    = "VariableDD";
const dropDownVars  =  ["cereal de invierno", "maíz", "frutales/vid"];

const params = {
    "serviceCode" : serviceCode,
    "serviceFolder" : serviceFolder,
    "serviceTitle" : serviceTitle,
    "dropDownId" : dropDownId,
    "dropDownVars" : dropDownVars
}

test.performTest(params); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Se importa la clase csTest</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Se instancia la clase csTest</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Se inicializan las variables específicas de cada visor</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Se ejecuta el test (método performTest)</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_ejecución_de_los_test">Ejecución de los test</h3>
<div class="paragraph">
<p>Para ejecutar los scirpt de test de cada visor, invocamos el comando <code>test</code> en la consola, dentro del directorio de la aplicación.</p>
</div>
<div class="listingblock">
<div class="title">Ejecución del test en el visor agro-meteorology-monitor</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">$ cd VisorServiciosClimaticos <i class="conum" data-value="1"></i><b>(1)</b>
$ npm -w agro-meteorology-monitor run test <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Nos situamos en el directorio</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Ejecucion propiamente dicha</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_toma_de_imágenes_de_pantalla_y_borrado_de_archivos">Toma de imágenes de pantalla y borrado de archivos</h3>
<div class="paragraph">
<p>La clase csTest dispone de dos métodos auxiliares:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>takeScreendhot: graba una imagen de pantalla en el momneto de que se invoca al método</p>
</li>
<li>
<p>deleteFiles: borra los archivos contenidos en la carpeta que se le pasa como parámetro</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Se utilizan para aportar información visual de apoyo a cada uno de los tests.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.1<br>
Last updated 2024-09-19 10:33:46 +0200
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>